webpackHotUpdate_N_E("pages/index",{

/***/ "./lib/use-scroll.ts":
/*!***************************!*\
  !*** ./lib/use-scroll.ts ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\nvar DELTA_STEP = 7;\nvar TRESHHOLD = 3 * DELTA_STEP;\nvar DRAG_THRESHOLD = 3 * DELTA_STEP;\n\nvar initState = function initState(init) {\n  return _objectSpread(_objectSpread({}, init), {}, {\n    index: 0,\n    offset: 0,\n    dragY: -1,\n    pageScrolled: false\n  });\n};\n\nvar isFirstPage = function isFirstPage(state) {\n  return state.index === 0;\n};\n\nvar isLastPage = function isLastPage(state) {\n  return state.index === state.totalPages - 1;\n};\n\nfunction isTouch(e) {\n  return e.touches !== undefined;\n}\n\nvar getClient = function getClient(event) {\n  console.log(isTouch(event) ? \"touchY: \".concat(event.touches[0].clientY) : \"mouseY: \".concat(event.clientY));\n  return isTouch(event) ? event.touches[0] : event;\n};\n\nvar preventDefault = function preventDefault(event) {\n  event.preventDefault();\n  event.stopPropagation();\n};\n\nvar scrollBy = function scrollBy(state, amount) {\n  var newOffset = state.offset + amount;\n  if (isFirstPage(state) && amount < 0 && newOffset < 0) return state;\n  if (isLastPage(state) && amount > 0 && newOffset > TRESHHOLD) return state;\n\n  if (Math.abs(newOffset) > TRESHHOLD) {\n    return _objectSpread(_objectSpread({}, state), {}, {\n      index: state.index + Math.sign(newOffset),\n      offset: 0,\n      pageScrolled: true\n    });\n  }\n\n  return _objectSpread(_objectSpread({}, state), {}, {\n    offset: newOffset\n  });\n};\n\nvar dragging = function dragging(state, clientY) {\n  var amount = (state.dragY - clientY) * 100 / state.pageSize;\n  var newOffset = state.offset + amount;\n  if (isFirstPage(state) && amount < 0 && newOffset < 0) return state;\n  if (isLastPage(state) && amount > 0 && newOffset > TRESHHOLD) return state;\n  return _objectSpread(_objectSpread({}, state), {}, {\n    dragY: clientY,\n    offset: newOffset\n  });\n};\n\nvar reducer = function reducer(state, action) {\n  if (state.pageScrolled) {\n    return action.type === 'UNFREEZE' ? _objectSpread(_objectSpread({}, state), {}, {\n      pageScrolled: false\n    }) : state;\n  }\n\n  switch (action.type) {\n    case 'BY_AMOUNT':\n      return scrollBy(state, action.payload);\n\n    case 'TO_INDEX':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        index: action.payload,\n        offset: 0,\n        pageScrolled: true\n      });\n\n    case 'DRAG_START':\n      if (state.dragY !== -1) return state;\n      preventDefault(action.payload);\n      return _objectSpread(_objectSpread({}, state), {}, {\n        dragY: getClient(action.payload).clientY\n      });\n\n    case 'DRAG':\n      if (state.dragY <= 0) return state;\n      preventDefault(action.payload);\n      return dragging(state, getClient(action.payload).clientY);\n\n    case 'DRAG_END':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        dragY: -1,\n        index: Math.abs(state.offset) > DRAG_THRESHOLD && !(isFirstPage(state) && state.offset < 0 || isLastPage(state) && state.offset > 0) ? state.index + Math.sign(state.offset) : state.index,\n        offset: isLastPage(state) && state.offset > 0 ? state.offset : 0,\n        pageScrolled: true\n      });\n\n    case 'RESIZE':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        pageSize: action.payload,\n        offset: 0,\n        dragY: -1\n      });\n\n    default:\n      return state;\n  }\n};\n\nvar useScroll = function useScroll(initParams) {\n  _s();\n\n  var _useReducer = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useReducer\"])(reducer, initParams, initState),\n      state = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\n    if (state.pageScrolled) {\n      setTimeout(function () {\n        dispatch({\n          type: 'UNFREEZE'\n        });\n      }, 1000);\n    }\n  }, [state.pageScrolled]);\n  return {\n    index: state.index,\n    offset: state.offset,\n    absOffset: state.offset / DELTA_STEP,\n    activeEnd: isLastPage(state) && state.offset / DELTA_STEP > 1,\n    scrollByAmount: function scrollByAmount(val) {\n      return dispatch({\n        type: 'BY_AMOUNT',\n        payload: val\n      });\n    },\n    scrollByStep: function scrollByStep(dir) {\n      return dispatch({\n        type: 'BY_AMOUNT',\n        payload: dir < 0 ? -DELTA_STEP : DELTA_STEP\n      });\n    },\n    scrollToIndex: function scrollToIndex(index) {\n      return dispatch({\n        type: 'TO_INDEX',\n        payload: index\n      });\n    },\n    startDrag: function startDrag(event) {\n      return dispatch({\n        type: 'DRAG_START',\n        payload: event\n      });\n    },\n    drag: function drag(event) {\n      return dispatch({\n        type: 'DRAG',\n        payload: event\n      });\n    },\n    endDrag: function endDrag() {\n      return dispatch({\n        type: 'DRAG_END'\n      });\n    },\n    resize: function resize(h) {\n      return dispatch({\n        type: 'RESIZE',\n        payload: h\n      });\n    }\n  };\n};\n\n_s(useScroll, \"m2z0qhC7ztC64kKVDga+TYLfOuQ=\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (useScroll);\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL3VzZS1zY3JvbGwudHM/NTlkOCJdLCJuYW1lcyI6WyJERUxUQV9TVEVQIiwiVFJFU0hIT0xEIiwiRFJBR19USFJFU0hPTEQiLCJpbml0U3RhdGUiLCJpbml0IiwiaW5kZXgiLCJvZmZzZXQiLCJkcmFnWSIsInBhZ2VTY3JvbGxlZCIsImlzRmlyc3RQYWdlIiwic3RhdGUiLCJpc0xhc3RQYWdlIiwidG90YWxQYWdlcyIsImlzVG91Y2giLCJlIiwidG91Y2hlcyIsInVuZGVmaW5lZCIsImdldENsaWVudCIsImV2ZW50IiwiY29uc29sZSIsImxvZyIsImNsaWVudFkiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInNjcm9sbEJ5IiwiYW1vdW50IiwibmV3T2Zmc2V0IiwiTWF0aCIsImFicyIsInNpZ24iLCJkcmFnZ2luZyIsInBhZ2VTaXplIiwicmVkdWNlciIsImFjdGlvbiIsInR5cGUiLCJwYXlsb2FkIiwidXNlU2Nyb2xsIiwiaW5pdFBhcmFtcyIsInVzZVJlZHVjZXIiLCJkaXNwYXRjaCIsInVzZUVmZmVjdCIsInNldFRpbWVvdXQiLCJhYnNPZmZzZXQiLCJhY3RpdmVFbmQiLCJzY3JvbGxCeUFtb3VudCIsInZhbCIsInNjcm9sbEJ5U3RlcCIsImRpciIsInNjcm9sbFRvSW5kZXgiLCJzdGFydERyYWciLCJkcmFnIiwiZW5kRHJhZyIsInJlc2l6ZSIsImgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBRUEsSUFBTUEsVUFBVSxHQUFHLENBQW5CO0FBQ0EsSUFBTUMsU0FBUyxHQUFHLElBQUlELFVBQXRCO0FBQ0EsSUFBTUUsY0FBYyxHQUFHLElBQUlGLFVBQTNCOztBQTZDQSxJQUFNRyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFDQyxJQUFEO0FBQUEseUNBQ2JBLElBRGE7QUFFaEJDLFNBQUssRUFBRSxDQUZTO0FBR2hCQyxVQUFNLEVBQUUsQ0FIUTtBQUloQkMsU0FBSyxFQUFFLENB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O0FBV0xrQixVQUFNLEVBQUUsZ0JBQUNDLENBQUQ7QUFBQSxhQUFlZCxRQUFRLENBQUM7QUFBRUwsWUFBSSxFQUFFLFFBQVI7QUFBa0JDLGVBQU8sRUFBRWtCO0FBQTNCLE9BQUQsQ0FBdkI7QUFBQTtBQVhILEdBQVA7QUFhRCxDQXZCRDs7R0FBTWpCLFM7O0FBeUJTQSx3RUFBZiIsImZpbGUiOiIuL2xpYi91c2Utc2Nyb2xsLnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZHVjZXIsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuXG5jb25zdCBERUxUQV9TVEVQID0gN1xuY29uc3QgVFJFU0hIT0xEID0gMyAqIERFTFRBX1NURVBcbmNvbnN0IERSQUdfVEhSRVNIT0xEID0gMyAqIERFTFRBX1NURVBcblxudHlwZSBNb3VzZUV2ZW50ID0gUmVhY3QuTW91c2VFdmVudDxIVE1MRWxlbWVudD5cbnR5cGUgVG91Y2hFdmVudCA9IFJlYWN0LlRvdWNoRXZlbnQ8SFRNTEVsZW1lbnQ+XG5cbnR5cGUgRHJhZ0V2ZW50ID0gTW91c2VFdmVudCB8IFRvdWNoRXZlbnRcblxuaW50ZXJmYWNlIFVuZnJlZXplQWN0aW9uIHtcbiAgdHlwZTogJ1VORlJFRVpFJ1xufVxuaW50ZXJmYWNlIFRvSW5kZXhBY3Rpb24ge1xuICB0eXBlOiAnVE9fSU5ERVgnXG4gIHBheWxvYWQ6IG51bWJlclxufVxuaW50ZXJmYWNlIEJ5QW1vdW50QWN0aW9uIHtcbiAgdHlwZTogJ0JZX0FNT1VOVCdcbiAgcGF5bG9hZDogbnVtYmVyXG59XG5pbnRlcmZhY2UgRHJhZ1N0YXJ0QWN0aW9uIHtcbiAgdHlwZTogJ0RSQUdfU1RBUlQnXG4gIHBheWxvYWQ6IERyYWdFdmVudFxufVxuaW50ZXJmYWNlIERyYWdBY3Rpb24ge1xuICB0eXBlOiAnRFJBRydcbiAgcGF5bG9hZDogRHJhZ0V2ZW50XG59XG5pbnRlcmZhY2UgRHJhZ0VuZEFjdGlvbiB7XG4gIHR5cGU6ICdEUkFHX0VORCdcbn1cbmludGVyZmFjZSBSZXNpemVBY3Rpb24ge1xuICB0eXBlOiAnUkVTSVpFJyxcbiAgcGF5bG9hZDogbnVtYmVyXG59XG50eXBlIFRoZUFjdGlvbiA9IFVuZnJlZXplQWN0aW9uIHwgVG9JbmRleEFjdGlvbiB8IEJ5QW1vdW50QWN0aW9uIHwgRHJhZ1N0YXJ0QWN0aW9uIHwgRHJhZ0FjdGlvbiB8IERyYWdFbmRBY3Rpb24gfCBSZXNpemVBY3Rpb25cblxuaW50ZXJmYWNlIEluaXRTdGF0ZSB7XG4gIHRvdGFsUGFnZXM6IG51bWJlcixcbiAgcGFnZVNpemU6IG51bWJlclxufVxuaW50ZXJmYWNlIFNjcm9sbFN0YXRlIGV4dGVuZHMgSW5pdFN0YXRlIHtcbiAgaW5kZXg6IG51bWJlclxuICBvZmZzZXQ6IG51bWJlclxuICBkcmFnWTogbnVtYmVyXG4gIHBhZ2VTY3JvbGxlZDogYm9vbGVhblxufVxuY29uc3QgaW5pdFN0YXRlID0gKGluaXQ6IEluaXRTdGF0ZSk6IFNjcm9sbFN0YXRlID0+ICh7XG4gIC4uLmluaXQsXG4gIGluZGV4OiAwLFxuICBvZmZzZXQ6IDAsXG4gIGRyYWdZOiAtMSxcbiAgcGFnZVNjcm9sbGVkOiBmYWxzZSxcbn0pXG5cbmNvbnN0IGlzRmlyc3RQYWdlID0gKHN0YXRlOiBTY3JvbGxTdGF0ZSkgPT4gc3RhdGUuaW5kZXggPT09IDBcbmNvbnN0IGlzTGFzdFBhZ2UgPSAoc3RhdGU6IFNjcm9sbFN0YXRlKSA9PiBzdGF0ZS5pbmRleCA9PT0gc3RhdGUudG90YWxQYWdlcyAtIDFcblxuXG5mdW5jdGlvbiBpc1RvdWNoKGU6IERyYWdFdmVudCk6IGUgaXMgVG91Y2hFdmVudCB7XG4gIHJldHVybiAoZSBhcyBSZWFjdC5Ub3VjaEV2ZW50PEhUTUxFbGVtZW50PikudG91Y2hlcyAhPT0gdW5kZWZpbmVkXG59XG5cbmNvbnN0IGdldENsaWVudCA9IChldmVudDogRHJhZ0V2ZW50KSA9PiB7XG4gIGNvbnNvbGUubG9nKGlzVG91Y2goZXZlbnQpID8gYHRvdWNoWTogJHtldmVudC50b3VjaGVzWzBdLmNsaWVudFl9YCA6IGBtb3VzZVk6ICR7ZXZlbnQuY2xpZW50WX1gKVxuICByZXR1cm4gKFxuICAgIGlzVG91Y2goZXZlbnQpID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50XG4gIClcbn1cblxuY29uc3QgcHJldmVudERlZmF1bHQgPSAoZXZlbnQ6IERyYWdFdmVudCkgPT4ge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG59XG5cbmNvbnN0IHNjcm9sbEJ5ID0gKHN0YXRlOiBTY3JvbGxTdGF0ZSwgYW1vdW50OiBudW1iZXIpOiBTY3JvbGxTdGF0ZSA9PiB7XG4gIGNvbnN0IG5ld09mZnNldCA9IHN0YXRlLm9mZnNldCArIGFtb3VudFxuICBpZiAoaXNGaXJzdFBhZ2Uoc3RhdGUpICYmIGFtb3VudCA8IDAgJiYgbmV3T2Zmc2V0IDwgMCkgcmV0dXJuIHN0YXRlXG4gIGlmIChpc0xhc3RQYWdlKHN0YXRlKSAmJiBhbW91bnQgPiAwICYmIG5ld09mZnNldCA+IFRSRVNISE9MRCkgcmV0dXJuIHN0YXRlXG4gIGlmIChNYXRoLmFicyhuZXdPZmZzZXQpID4gVFJFU0hIT0xEKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgaW5kZXg6IHN0YXRlLmluZGV4ICsgTWF0aC5zaWduKG5ld09mZnNldCksXG4gICAgICBvZmZzZXQ6IDAsXG4gICAgICBwYWdlU2Nyb2xsZWQ6IHRydWUsXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgb2Zmc2V0OiBuZXdPZmZzZXRcbiAgfVxufVxuY29uc3QgZHJhZ2dpbmcgPSAoc3RhdGU6IFNjcm9sbFN0YXRlLCBjbGllbnRZOiBudW1iZXIpOiBTY3JvbGxTdGF0ZSA9PiB7XG4gIGNvbnN0IGFtb3VudCA9IChzdGF0ZS5kcmFnWSAtIGNsaWVudFkpICogMTAwIC8gc3RhdGUucGFnZVNpemVcbiAgY29uc3QgbmV3T2Zmc2V0ID0gc3RhdGUub2Zmc2V0ICsgYW1vdW50XG4gIGlmIChpc0ZpcnN0UGFnZShzdGF0ZSkgJiYgYW1vdW50IDwgMCAmJiBuZXdPZmZzZXQgPCAwKSByZXR1cm4gc3RhdGVcbiAgaWYgKGlzTGFzdFBhZ2Uoc3RhdGUpICYmIGFtb3VudCA+IDAgJiYgbmV3T2Zmc2V0ID4gVFJFU0hIT0xEKSByZXR1cm4gc3RhdGVcbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBkcmFnWTogY2xpZW50WSxcbiAgICBvZmZzZXQ6IG5ld09mZnNldCxcbiAgfVxuXG59XG5cbmNvbnN0IHJlZHVjZXIgPSAoc3RhdGU6IFNjcm9sbFN0YXRlLCBhY3Rpb246IFRoZUFjdGlvbikgPT4ge1xuICBpZiAoc3RhdGUucGFnZVNjcm9sbGVkKSB7XG4gICAgcmV0dXJuIGFjdGlvbi50eXBlID09PSAnVU5GUkVFWkUnID8geyAuLi5zdGF0ZSwgcGFnZVNjcm9sbGVkOiBmYWxzZSB9IDogc3RhdGVcbiAgfVxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnQllfQU1PVU5UJzpcbiAgICAgIHJldHVybiBzY3JvbGxCeShzdGF0ZSwgYWN0aW9uLnBheWxvYWQpXG4gICAgY2FzZSAnVE9fSU5ERVgnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGluZGV4OiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBwYWdlU2Nyb2xsZWQ6IHRydWUsXG4gICAgICB9XG4gICAgY2FzZSAnRFJBR19TVEFSVCc6XG4gICAgICBpZiAoc3RhdGUuZHJhZ1kgIT09IC0xKSByZXR1cm4gc3RhdGVcbiAgICAgIHByZXZlbnREZWZhdWx0KGFjdGlvbi5wYXlsb2FkKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGRyYWdZOiBnZXRDbGllbnQoYWN0aW9uLnBheWxvYWQpLmNsaWVudFlcbiAgICAgIH1cbiAgICBjYXNlICdEUkFHJzpcbiAgICAgIGlmIChzdGF0ZS5kcmFnWSA8PSAwKSByZXR1cm4gc3RhdGVcbiAgICAgIHByZXZlbnREZWZhdWx0KGFjdGlvbi5wYXlsb2FkKVxuICAgICAgcmV0dXJuIGRyYWdnaW5nKHN0YXRlLCBnZXRDbGllbnQoYWN0aW9uLnBheWxvYWQpLmNsaWVudFkpXG4gICAgY2FzZSAnRFJBR19FTkQnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGRyYWdZOiAtMSxcbiAgICAgICAgaW5kZXg6IE1hdGguYWJzKHN0YXRlLm9mZnNldCkgPiBEUkFHX1RIUkVTSE9MRCAmJiAhKChpc0ZpcnN0UGFnZShzdGF0ZSkgJiYgc3RhdGUub2Zmc2V0PDApIHx8ICAoaXNMYXN0UGFnZShzdGF0ZSkgJiYgc3RhdGUub2Zmc2V0ID4gMCkpID8gc3RhdGUuaW5kZXggKyBNYXRoLnNpZ24oc3RhdGUub2Zmc2V0KSA6IHN0YXRlLmluZGV4LFxuICAgICAgICBvZmZzZXQ6IGlzTGFzdFBhZ2Uoc3RhdGUpICYmIHN0YXRlLm9mZnNldCA+IDAgPyBzdGF0ZS5vZmZzZXQgOiAwLFxuICAgICAgICBwYWdlU2Nyb2xsZWQ6IHRydWVcbiAgICAgIH1cbiAgICBjYXNlICdSRVNJWkUnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIHBhZ2VTaXplOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBkcmFnWTogLTEsXG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZVxuICB9XG59XG5cblxuXG5jb25zdCB1c2VTY3JvbGwgPSAoaW5pdFBhcmFtczogSW5pdFN0YXRlKSA9PiB7XG4gIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0UGFyYW1zLCBpbml0U3RhdGUpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHN0YXRlLnBhZ2VTY3JvbGxlZCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ1VORlJFRVpFJyB9KVxuICAgICAgfSwgMTAwMClcbiAgICB9XG4gIH0sIFtzdGF0ZS5wYWdlU2Nyb2xsZWRdKVxuXG4gIHJldHVybiB7XG4gICAgaW5kZXg6IHN0YXRlLmluZGV4LFxuICAgIG9mZnNldDogc3RhdGUub2Zmc2V0LFxuICAgIGFic09mZnNldDogc3RhdGUub2Zmc2V0IC8gREVMVEFfU1RFUCxcbiAgICBhY3RpdmVFbmQ6IGlzTGFzdFBhZ2Uoc3RhdGUpICYmIHN0YXRlLm9mZnNldCAvIERFTFRBX1NURVAgPiAxLFxuICAgIHNjcm9sbEJ5QW1vdW50OiAodmFsOiBudW1iZXIpID0+IGRpc3BhdGNoKHsgdHlwZTogJ0JZX0FNT1VOVCcsIHBheWxvYWQ6IHZhbCB9KSxcbiAgICBzY3JvbGxCeVN0ZXA6IChkaXI6IG51bWJlcikgPT4gZGlzcGF0Y2goeyB0eXBlOiAnQllfQU1PVU5UJywgcGF5bG9hZDogZGlyIDwgMCA/IC0gREVMVEFfU1RFUCA6IERFTFRBX1NURVAgfSksXG4gICAgc2Nyb2xsVG9JbmRleDogKGluZGV4OiBudW1iZXIpID0+IGRpc3BhdGNoKHsgdHlwZTogJ1RPX0lOREVYJywgcGF5bG9hZDogaW5kZXggfSksXG4gICAgc3RhcnREcmFnOiAoZXZlbnQ6IERyYWdFdmVudCkgPT4gZGlzcGF0Y2goeyB0eXBlOiAnRFJBR19TVEFSVCcsIHBheWxvYWQ6IGV2ZW50IH0pLFxuICAgIGRyYWc6IChldmVudDogRHJhZ0V2ZW50KSA9PiBkaXNwYXRjaCh7IHR5cGU6ICdEUkFHJywgcGF5bG9hZDogZXZlbnQgfSksXG4gICAgZW5kRHJhZzogKCkgPT4gZGlzcGF0Y2goeyB0eXBlOiAnRFJBR19FTkQnIH0pLFxuICAgIHJlc2l6ZTogKGg6IG51bWJlcikgPT4gZGlzcGF0Y2goeyB0eXBlOiAnUkVTSVpFJywgcGF5bG9hZDogaCB9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVNjcm9sbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/use-scroll.ts\n");

/***/ })

})